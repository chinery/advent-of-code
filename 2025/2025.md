## 2025 Thoughts

### Intro

I should take some notes else I'll forget. Don't imagine anyone will read this but comments always welcome.

After a few years off for me, a colleague and I thought AoC might be a nice activity for the developers at our company. The drop to 12 problems instead of 25 was a coincidence, but I thought might take a bit of pressure off people to keep up each day and mean more people actually complete it by the end of the month.

..._fwiw as of day 7, unsure if it made any difference ‚Äì the race for the leaderboard means there's no chill at the top, and the people who got stuck on day 1/2 quickly dropped off. hopefully we can encourage people to pick it back up_

### Challenge
I decided to do each day of this year's puzzles in a different programming language.

At the time I knew it was a silly idea, it's not like I'm a polyglot. But I wanted to challenge myself, and there was no one specific ‚Äúnew‚Äù language I wanted to commit to for the full thing. And 12 languages is much more manageable than 25.

I'm allowing myself to see the puzzle before I commit to the day's language, but typically I prepare/install something the night before, so I have an idea. In theory I am also allowing myself to go back and re-do an early puzzle in a new language, if I need to free up a language I know well. But I think I'll be okay...

Let's be clear that I don't know 12 languages, not properly. I've been asking developers and ChatGPT for suggestions. It's important to me to try to stay idiomatic to the language. I don't want each answer to just be Python shoved into an X shaped hole.

#### The List
The languages I've used so far for each day
1. [Python](#day-1--python)
2. [Typescript/Node.js](#day-2--javascripttypescriptnodejs)
3. [C#](#day-3-c)
4. [Hy](#day-4--hy)
5. [Rust](#day-5--rust)
6. [J](#day-6--j)
7. [Nim](#day-7-nim)
8. [Octave](#day-8--octave)
9. [Mojo](#day-9--mojo)
9. [Swift](#day-10--swift)

Languages on my list for future days, that I've used before...
- Swift
- C++

...and that I haven't
- Julia
- Gleam
- Ruby/Crystal

and if I see some sort of backtracking constraint satisfaction problem, maybe I'll try Prolog? (I want to understand it better, but I suspect it's not the right venue.)

### Daily notes
#### Day 1 ‚Äì Python
I saved the problem for a lunch time Teams call. I'd sort of planned to share my screen and solve it with the group, but in the moment remembered how hard that is, and also wanted everyone else to have a chance to have a go on their own before we discussed it.

I actually found day_1_2 one of the most fiddly problems so far, but maybe being on the call didn't help. Handling the edge case of what happens when the dial lands on zero (and not double counting it) definitely hurt my head a bit.

I was proud of one little thing in my implementation, one of those "if you spot it" tricks that makes things a little easier, which is that any command like `L635` can be processed as 6 full turns, and then `L35`. Think that helped avoid some potential annoyances later.

#### Day 2 ‚Äì Javascript/Typescript/Node.js
Starting with the two languages I use most often was partly to force myself to solve harder problems with new languages, but mostly laziness (and I had some work deadlines that were < day 3).

I started in Javascript but got annoyed at the lack of types for code completion inside functions. No other comments on JS/TS/Node as a language really.

But today's puzzle was a perfect illustration of how the way you approach a problem can have huge implications for efficiency. Except it turns out you could brute force it in a sensible amount of time for the inputs provided.

In short: given many ranges like 121000-343000, find all numbers that are made of repeating substrings, like 121212 or 150150. And the ranges are made of huge numbers.

A natural idea is: 
```python
for i in range(121000, 343000+1):
    if test(str(i)) # ...
```
and then you think ‚Äúhow do I make `test` as efficient as possible?‚Äù. And in that case, a regex is a really neat solution e.g. `^(\d)+\1+$` (Almost so powerful it's cheating! And worth pointing out that this language is [not regular](https://en.wikipedia.org/wiki/Regular_language) ‚Äì being able to do backreferences makes modern regex engines really quite expressive.)

But this is what I'm calling "brute-force" ‚Äì you don't need to iterate through every possible number and test it, because you can describe every number that meets the criteria. 

Instead, what if we look at our start value `121000`, and notice its length is divisible by 2 and 3 (1 and 6 are ruled out by the puzzle rules). Starting with 2, we take the first two digits `12` and notice that the next repeating substring is obviously `121212`, then `131313`, then `141414`, and so on. We can do the same with length 3 -> `121` so: `121121`, `122122`, `123123`, ... (_nb. obviously here by "notice" I mean "compute"_)

Generators (functions that yield) are a really neat syntax for this sort of thing, and luckily for me Typescript supports them well!

Now the problem is just a matter of the start/end conditions (fiddly to do purely in string land but not that bad, or you could just do a numerical test), and then summing up all the values into something that won't overflow/lose precision.

In a quick test, the generator approach was roughly 100x faster than the brute-force regex one:

```
Generator:   2.475917 ms
Regex:     356.105417 ms
```

If the input had been hard enough to make ms into s, you'd feel it!

#### Day 3 ‚Äì¬†C#
A language I haven't used properly since around 2008, so I came in expecting things to be quite different.

Getting things running in VS Code on macOS was fine, all things considered (no need for mono these days), and once it was working, everything was working (debugging etc). I like the new (to me) support for more "script-like" files that have top level statements, which simplifies the entry point ‚Äì minor but especially nice for AoC.

As someone who's moved on from Java/C#, it's actually interesting coming back to try to find the right balance of "thinking in OOP". The ceremony around visibility is still there but life is generally easier with simplified constructor calls, properties, parameters on the class definition...

Post-submission, I actually built a second version of my solution using a LinkedList rather than an array, so I even got to write an abstract class!

LINQ features don't feel novel any more now that functional map/filter/reduce is so common, but that makes it easier to use.

For the third day in a row, I felt like I managed to avoid some pitfalls approaching the problem. As soon as I started thinking about trying to scan a string forwards and backwards, I knew I needed to stop and think: can I do it in one pass? Start with the 12 leftmost digits, then consider what needs to change as you parse each digit in the remainder of the string.

I tried that manually, and came up with some rules, which ended up being complete but not succinct! So there were a few post-submission improvements.

#### Day 4 ‚Äì Hy
I decided I needed to reserve some languages I had used before for later days, so after a chat with ChatGPT, I settled on Hy. I wanted something functional, something Lispy, and so something that ultimately used the Python runtime made a lot of sense to avoid some type related headaches.

I enjoyed trying to write Lispy code again but I'm very rusty (and not [in a good way](#day-5--rust)).

I think I'm right to say that if you've got a 2D grid, it's kind of unavoidable that you'll have `gfor`/`lfor` "loops". But I tried to make the program flow recursive.

Today I also realised just how bad LLMs are with less mainstream languages. I obviously don't use Copilot or pass any of the puzzle in, but I am using them to ask questions that are similar to search, e.g. "I'm trying to process a grid like a convolution, does this look too procedural rather than functional?". 

ChatGPT gave (what seemed like) very good advice about style, but it was **awful** at giving correct syntax suggestions. e.g. "how do I get the first/rest, like `car/cdr` in Lisp?", and it said "use `(first [0 1 2]), (rest [0, 1, 2])`, but that just doesn't work, and it was almost impossible to Google. Post-submission digging, it seems like they used to be part of the language, but `rest` was moved into `hyrule`, and `first` got left out.

#### Day 5 ‚Äì Rust
I had to see what all the buzz was about!

Well, it was great. I like all the options for result unpacking ‚Äì from "just do it" to "let's handle this with an error message" to "okay this should probably be handled properly" (which I don't think I actually needed for this toy puzzle).

I especially like move-on-assignment, now that's an interesting idea! 

For part one I just didn't feel I would need optimisation beyond sorting the ranges. I'd need to go through each ingredient anyway. I considered collapsing the ranges and then iterating through ingredients and ranges at the same time (a bit like a merge sort). In retrospect, I think it could be done in a single pass (collapse and count). But I was aware of the leaderboard (!) and decided that for a relatively small number of ingredients, just not having to scan the entire set of ranges would be fast enough.

For part two, I scanned the ranges in one pass. Initially I implemented a lookahead which truncated the current range if it overlapped a subsequent range. To deal with fully subsumed ranges, I was using a set to mark ranges I could skip on future iterations. 

Even this was faster than part one. But after speaking with a colleague about his solution, I realised it was much simpler to just keep a running start/end, and update the end value until you find a range that has a gap (where `start > runningEnd`).

Rust is meant to be fast so I had to time it. `94.5¬µs` for part two on my M1 MacBook, if I switch off low power mode and put it in release profile. Seems fast enough I guess!

#### Day 6 ‚Äì J

In my first chat with ChatGPT, it said: 
> #### APL or J
> - If you want to spend an evening feeling like you‚Äôve joined a secret cult.
> - Ridiculous power density for array puzzles.
> - Harder to ‚Äústay idiomatic‚Äù without understanding the language deeply, but incredibly fun.

When I told a colleague about the challenge, he asked if I was going to use an array language like APL. I've used a lot of Matlab and NumPy, so array/vector thinking isn't new to me. But J is the first ‚Äúterse‚Äù language I've tried ‚Äì I've seen those wild golf solutions before, but never tried to understand them. I didn't actually know there was a link between the two. 

So, anyway, I felt like I had to try on the first weekend day.

The J Primer is so pretentious...but I don't think it's wrong when it says
> You could study and use it for years, and still consider yourself a beginner. This is in sharp contrast to simpler languages like Basic or Java, where months of concerted study and use would make you an expert.

Using `jconsole` repl to play around with the data was a good experience, and the right-to-left evaluation makes it very natural to end up with long chains of operators without assigning anything to a variable, so I see how the ridiculous terse programs come about.

In my first attempt I did too much boxing and unboxing. I slightly refactored it out of my part two code after submission but you can still see it in part one. 

I also overcomplicated the part two approach first time. I immediately thought I could just transpose the input, which was the right idea...but I added some logic to split on spaces in the wrong place, and that meant the inputs didn't align properly when transposed. I solved it by adding extra spaces to the input to pad each input to the maximum length, which worked...

```J
NB. find the start of each set of columns
cutPoints =: -. (opRow = ' ')
NB. find the size of longest group of columns
maxCellLen =: >./ > # each cutPoints <;.1"1 opRow
NB. cut the operands into boxes at the cutPoints, then pad each box
paddedCells =: maxCellLen $!. ' ' each cutPoints <;.1"1 operandRows
NB. unbox, and transpose
transposed =: 0 |: > paddedCells
NB. convert to numbers, filter to '+'s, and sum
sum =: +/ I: (-. isMult) # (0 ". transposed)
```

But it was much better to just embrace boxes!

```J
NB. transpose, convert to numbers, split on spaces into boxes
NB. (need to keep as boxes because non-equal number of operands per sum)
operands =: <;._1 (_1, (_1 ". |: operandRows))
NB. sum/mult within boxes first, then unbox and sum
sum =: +/ > +/ each (-. isMult) # operands
```

I think it could be made even more Jish. There's probably a good way to selectively map `*` and `+` over the list of boxes in one line instead of doing them separately. 

But also, while the puzzle was very suited to array processing in one sense (transposing the input) it's also still fundamentally about parsing strings correctly, which is not really what J is designed for.

Final thought: the LLM issue _really_ struck here. Almost all code that ChatGPT wrote simply didn't work the way it said it would (if it even ran). I asked it to review my code, and it gave some really sensible top level advice e.g. pointing out that I was boxing/unboxing too much rather than dealing with structure first and then chaining functions. But then it tried to make code suggestions ‚Äì it misunderstood what the code was doing, gave broken code samples, and even gave some suggestions that were identical to what I'd written (then said "which is what you're already doing, great").

#### Day 7 ‚Äì¬†Nim
I was in the mood for something a bit more Python like today.

Getting Nim to work nicely in VS Code was a nightmare! Using the official extension tried to install `nimlangserver`, which would fail repeatedly, possibly because it had a dependency on an older version of `nim`? Once I told it to use the system installation, it did work, and I started getting inferred types and errors inline. But it didn't take long for errors to start lagging behind the actual code. Clicking "play" in the toolbar just built the code and didn't run it??

Switching to the _other_ Nim extension (which has more stars, in fairness) seemed to fix it, but I still had to run via the command palette.

VS Code issues aside. I like Nim's emphasis on making custom types. I think it's weird that `set` is actually a bit set, but that's what I was looking for. 

I really like the syntax that UFCS allows
```nim
let lines = filename.readFile.strip.splitLines
```

until it doesn't?
```nim
var beamCount: BeamCount = lines[0].len.newSeq[int]
# error:¬†expression 'newSeq(len(lines[0]))' has no type (or is ambiguous)
```

Maybe there's another option here I'm missing. But as is becoming a theme...the LLMs were confidently useless!

The puzzle itself was quite unremarkable ‚Äì just don't fall into the trap of feeling like you've got to keep track of anything you don't actually have to! 

#### Day 8 ‚Äì Octave
I didn't spend 4 years doing my PhD in MATLAB for nothing!


https://github.com/user-attachments/assets/89d75c1e-ed3e-4dff-b97e-616c255b35bb



Maybe using `pdist2` is slightly cheating for this puzzle? I'll have to check how it's implemented. I thought it might at least blink calculating distances between all pairs of 1,000 points, but no problem.

Other than that...it's ~~MATLAB~~Octave! Did I get tripped up by off-by-one errors trying to index arrays from zero? Yes. But only like 3 times.

I did find it really amusing that the built-in package manager required me to go and install dependencies myself before it would install the statistics package. (Well, dependency ‚Äì that could have gotten boring fast.)

#### Day 9 ‚Äì Mojo
Big step up in difficulty today! And trying an experimental language didn't necessary help...though in hindsight, the hardest part was just getting ideas out of my head and onto the page.

GPU support was a headline feature, and I thought that might be fun...but it just wasn't that sort of puzzle. I considered it for part one, but after looking into it more, it turns out it still requires the all the usual cermony to set up memory buffers etc. I'd hoped it might be a bit more ergonomic!

`.üî•` as a file extension is just funny for some reason. And [pixi](https://pixi.sh/latest/) seems like a good package manager.

Dealing with low level compiler errors leaking through, like `operand #0 does not dominate this use`, is not very convenient for AoC puzzle solving. But I got to learn at least a tiny bit more about how compilers work. Once I got the data loaded and was processing points, I just ended up using Mojo like most any other language...

Deep into part two things started getting messy. I had drawn some examples on paper and felt like I had some rules...what makes something an ‚Äúinner‚Äù/‚Äúouter‚Äù corner, how to keep track of which side of a corner is inside the shape... I worked on the principle of: "part one was brute force (checking every pair of points) and ran quickly enough, so I can do the same again, the question is just how to check if a pair of points is inside the shape". All my pre-processing to determine corner types did end up working first time, which is good, because I was barely understanding my own code as I was writing it. 

But the answer was wrong. This was approaching midnight, so I got some Copilot assistance to turn the list of points into an SVG. Just before I got it to draw my code's largest rectangle, I had the final lightbulb moment ‚Äì it wasn't enough to check if the rectangle contained any other point, it needed to be any other _line_.

The whole thing could be made significantly more efficient with a better data structure, some kind of quadtree or bsp. But at this time of night I just needed the answer. I always think about going back to tidy up code, maybe with 12 days total I actually will.

#### Day 10 ‚Äì Swift
This one took up all of day 10 and 11. As conceptually hard as day 9, but computationally so much worse. 

My comment above about backtracking constraint propagation is haunting me. I did consider Prolog. But I think it could have finished me off!

I realised the problem could be reduced to simulataneous equations, and spent some time looking at linear alegebra options in Swift, and even got a bunch of LAPACK examples running. But this wasn't the right idea ‚Äì a little knowledge is dangerous. I could find solutions to the linear system, but they ended up being non-integer, and/or non-minimal. So I turned to a simplified Gaussian elimination process. But...of course...most of the inputs are underconstrained. I had depth first search implemented for once I'd exhausted the row reductions...buuuut it was clear that the code would never finish running. 

If you know that `a + b = 5`, then generating all options with a function like `f(2, 5) = [[5,0], [4,1], [3,2], [2,3], [1,4], [0,5]]` is not so bad!

Unfortunately, if you know that `a + b + c + d + e = 101`, then you're in for a bad time...if I'd had a nice generator syntax like Python's `yield` this would have been better, but Swift's equivalent requires you to do all the tracking yourself.

There was some kind of bug in my first attempt to combine alternating steps of constraint reduction and DFS, it got an answer that was too low. I rewrote it, keeping the problem in the constraint domain. It initially looked like it was running faster, but it still took about 30 minutes to get the right answer!

Afterwards I looked up a CSP Swift library, and even that admits that performance is not great on medium-large domains. Again, if I have time I'd like to come back and try it. But as much as I like Swift's structs and copy-on-write, this does not make for efficient search. In retrospect, that aforementioned "find all options" function is probably the worst culprit.

I'd also genuinely like to know if Prolog can be used sensibly here. Another area for further investigation, if I need something to fill the rest of December!
